<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>iOS 解决数组强引用的问题 | fminor 的个人博客</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/very-simple.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"></head><body><!-- include the sidebar--><!-- include ./includes/sidebar.jade--><!-- Blog title and subtitle--><header><div class="container header"><a id="logo" href="/." class="title">fminor 的个人博客</a><span class="subtitle">-- for General CJ</span><label id="toggle-menu" for="menu" onclick><i class="fa fa-bars"></i></label></div></header><!-- use checkbox hack for toggle nav-bar on small screens--><input id="menu" type="checkbox"><!-- Navigation Links--><nav id="nav"><div class="container"><a href="/" class="sidebar-nav-item active">Home</a><a href="/archives" class="sidebar-nav-item">Archives</a></div></nav><div id="header-margin-bar"></div><!-- gallery that comes before the header--><div class="wrapper"><div class="container post-header"><h1>iOS 解决数组强引用的问题</h1></div></div><div class="wrapper"><div class="container meta"><div class="post-time">2017-08-04</div></div></div><article><div class="container post"><p>一、问题背景</p>
<p>在平时的项目开发中，经常会写到一些全局性的模块，使用单例的设计模式，比如音频 app 的播放器，下载器等。对于单例来说，常常涉及到事件的广播，广播我常常采用两种做法：</p>
<ol>
<li>触发事件时单例发送 Notification</li>
<li>观察者注册为单例的 delegate，单例模块维护一个 delegate 的数组，在触发事件时调用 delegate 相应的协议方法</li>
</ol>
<p>当然还有其他的做法，比如 delegate 换成 block 的形式，单例维护的是一个 block 的数组。 几种方法目前我个人觉得相差不是很大，没有谁比谁更好的问题（当然，前提是用于“广播”，比如仅仅一个 table view cell 的某个 UI 控件触发事件回调，显然采用 Notification 来实现并不合适）。我更喜欢采用的是第二种实现方法，因为 delegate 的 protocol 方法可以自动补全，仅此而已。</p>
<p>比如，最近项目中用 swift 新写的一个全局播放器 QDPlayAgent, 有如下的 delegate 数组:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class QDPlayAgent: NSObject &#123;</span><br><span class="line"></span><br><span class="line">	static var shared = QDPlayAgent()</span><br><span class="line">	</span><br><span class="line">	var delegates: [QDPlayAgentDelegate] = []</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	func add(delegate: QDPlayAgentDelegate) &#123;</span><br><span class="line">		// if delegates contain delegate, return.</span><br><span class="line">		// else</span><br><span class="line">		self.delegates.append(delegate)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	func remove(delegate: QDPlayAgentDelegate) &#123; </span><br><span class="line">		self.delegates.filter &#123;</span><br><span class="line">			$0.isEqual(delegate) == false</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@objc protocol QDPlayAgentDelegate: NSObjectProtocol &#123;</span><br><span class="line"></span><br><span class="line">    @objc optional func qd_playAgent(_ playAgent: QDPlayAgent, startToLoad item: ...)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其他对象需要观察播放器的状态时，只需要<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// implementation of class A</span><br><span class="line"></span><br><span class="line">	init() &#123;</span><br><span class="line">		...</span><br><span class="line">		QDPlayAgent.shared.add(delegate: self)</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	deinit() &#123;</span><br><span class="line">		...</span><br><span class="line">		QDPlayAgent.shared.remove(delegate: self)</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 并实现 delegate 方法即可</span><br><span class="line"></span><br><span class="line">	func qd_playAgent(_ playAgent: QDPlayAgent, startToLoad item: ...) &#123;</span><br><span class="line">		// do other things</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是这里带来一个问题，就是在对象 instance A 注册为 delegate 时，这个 QDPlayAgent 单例会把该对象添加到 delegates 数组中，而实验下来数组对于对象是强引用的持有。因而只要忘记在合适的时机调用 remove(delegate: QDPlayAgentDelegate) 方法的话，只要 QDPlayAgent 不释放一直持有 delegates 数组，则 instance A 也无法被释放，而 QDPlayAgent 作为单例在 app 的生命周期中几乎是一直存在的。因此：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deinit() &#123;</span><br><span class="line">	...</span><br><span class="line">	QDPlayAgent.shared.filter </span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这一段代码讲永远不会被执行。</p>
<p>二、解决方案</p>
<p>解决这个问题的第一个办法就是在合适的位置调用 remove 方法，但它不够一劳永逸，而且容易给其他同事带来坑。而要彻底解决这个问题，只要对 delegate 再包一层”壳“即可。单例 delegate 数组对”壳“是强引用持有，而”壳“对实际的观察者对象是弱引用持有：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">             strong                   weak    </span><br><span class="line">delegates -----------&gt; container - - - - - -&gt; instance</span><br></pre></td></tr></table></figure>
<p>这个”壳”（也就是 container）的实现非常简单，在下写了简单的类 QDWeakProxy 仅仅持有一个 weak 指针：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class QDWeakProxy&lt;T: NSObjectProtocol&gt;: NSObject &#123;</span><br><span class="line"></span><br><span class="line">    weak var value: T?</span><br><span class="line">    </span><br><span class="line">    init(value: T?) &#123;</span><br><span class="line">        self.value = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里涉及到许多小问题，比如为什么泛型 T 为什么要继承（或实现） NSObjectProtocol 协议，QDWeakProxy 为什么要继承自 NSObject，Swift 的 Class 和 NSObject 继承出来的 class 有什么区别，等等。这些问题平时做项目进度紧张可能不会细究，下个阶段有空时我再梳理一下其中的细节问题。</p>
<p>对 QDPlayAgent 单例来说，此时 delegates array 不再是 [QDPlayAgentDelegate] 数组，而是 [QDWeakProxy<qdplayagentdelegate>]数组，add 和 remove 方法，以及触发事件的回传代码也改成如下形式：</qdplayagentdelegate></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// implementation of QDPlayAgent</span><br><span class="line"></span><br><span class="line">func add(delegate: QDPlayAgentDelegate) &#123;</span><br><span class="line">	// if delegates contain delegate, return.</span><br><span class="line">	// else</span><br><span class="line">	self.delegates.append(QDWeakProxy(value: delegate))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func remove(delegate: QDPlayAgentDelegate) &#123; </span><br><span class="line">       self.delegates = self.delegates.filter &#123; (proxy) -&gt; Bool in</span><br><span class="line">           proxy.value?.isEqual(delegate) == false</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // 回调示例</span><br><span class="line">   func startToLoad() &#123;</span><br><span class="line">   	... </span><br><span class="line">   	self.delegates.forEach &#123; (delegate) in</span><br><span class="line">   		// 原本为 delegate.qd_playAgent?(self, startToLoad: ...)</span><br><span class="line">   		delegate.value?.qd_playAgent?(self, startToLoad: ...)</span><br><span class="line">   	&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>而对于外部的观察者 instance A 来说，是不需要改任何代码的。由于 QDWeakProxy 持有 instance A 的弱引用，instance A 的引用计数可以正常清零。此时 deinit 能够正常调用 remove(delegate: ) 方法，将持有一层壳的 QDWeakProxy 实例移出 delegates 数组。</p>
<p>三、采用 Swift 的 protocol 实现 QDWeakDelegatesProtocol</p>
<p>如果有另一个 class 也有自己用于广播的 delegate 协议以及持有了数组，相应的也会有 add(delegate:) 和 remove(delegate:) 方法。而在它的实现中，所不同的仅仅是协议的类型不同，add 和 remove 的逻辑是相同的。因此，可以把这段逻辑单独作为一个 QDWeakDelegatesProtocol，通过 extension 实现 add 和 remove 方法。这样，只要有其他 class 也需要有类似的广播逻辑，只要单独定义协议类型，并声明这个 class 实现 QDWeakDelegatesProtocol 即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">protocol QDWeakDelegatesProtocol: NSObjectProtocol &#123;</span><br><span class="line">    </span><br><span class="line">    associatedtype T: NSObjectProtocol</span><br><span class="line">    </span><br><span class="line">    var delegates: [QDWeakProxy&lt;T&gt;] &#123; get set &#125;</span><br><span class="line">    </span><br><span class="line">    func add(delegate: T) -&gt; Void</span><br><span class="line">    </span><br><span class="line">    func remove(delegate: T) -&gt; Void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension QDWeakDelegatesProtocol &#123;</span><br><span class="line">    </span><br><span class="line">    func add(delegate: T) -&gt; Void &#123;</span><br><span class="line">        if self.delegates.contains(where: &#123; (proxy) -&gt; Bool in</span><br><span class="line">            return proxy.value?.isEqual(delegate) ?? false</span><br><span class="line">        &#125;) &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        self.delegates.append(QDWeakProxy(value: delegate))</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func remove(delegate: T) -&gt; Void &#123;</span><br><span class="line">        self.delegates = self.delegates.filter &#123; (proxy) -&gt; Bool in</span><br><span class="line">            proxy.value?.isEqual(delegate) == false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而最终 QDPlayAgent 实现事件广播的代码只需要两行就可以做到了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class QDPlayAgent: NSObject, QDWeakDelegatesProtocol &#123;</span><br><span class="line">    </span><br><span class="line">    static let shared: QDPlayAgent = QDPlayAgent()</span><br><span class="line">    </span><br><span class="line">    typealias T = QDPlayAgentDelegate</span><br><span class="line">    var delegates: [QDWeakProxy&lt;T&gt;] = []</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><!-- comment system--><div class="container"><hr><div data-thread-key="2017/08/04/iOS解决数组强引用的问题/" data-title="iOS 解决数组强引用的问题" data-url="http://yoursite.com/2017/08/04/iOS解决数组强引用的问题/" class="ds-thread"></div><script>var duoshuoQuery = {short_name:'fminor'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
        || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script></div></article><footer id="footer"><div class="container"><div class="bar"><div class="social"><a href="/atom.xml" target="_blank"><i class="fa fa-rss"></i></a></div><div class="footer">© 2017 <a href="/" rel="nofollow">fminor 的个人博客</a>. Powered by <a rel="nofollow" target="_blank" href="https://hexo.io">Hexo</a>. Theme <a target="_blank" href="https://github.com/lotabout/very-simple">very-simple</a>.</div></div></div></footer><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
    $(".fancybox").fancybox();
});</script></body></html>